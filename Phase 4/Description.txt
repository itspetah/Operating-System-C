Phase 4 (Sim04) – Multiprogramming Simulator (Tentative – for reference)
DESCRIPTION
This phase will mark the culmination of how a multiprogramming operating system works. The program will extend the previous programming assignments in such a way that a user can view an operating system in action. The Sim04 system must effectively demonstrate concurrency with reasonably correct times for running and I/O operations. Threads may be used but are not required as long as the concurrency requirement is met; the program must appear to run the I/O operations in parallel with the run and housekeeping operations and as mentioned, the times for the I/O operations returning from their work (as interrupts) must be pretty close to the correct times. As before, all of the requirements of the previous assignment phases must still be supported, which includes the ability to run one or more programs with FCFS-N (i.e., first come, first served, non-preemptive) and SJF-N (i.e., shortest job first, non-preemptive) scheduling strategies on any set of given meta-data. In addition, all previous specifications still remain, such as no use of various sleep functions, clean, readable programming code, correct assignment file naming and management, etc. It would be a good idea to review these before attempting this next project. New requirements are specified below.
- threads may optionally be used for all I/O operations as needed; extra credit will be earned for correct use of threads. For any of the new strategies, which are FCFS-P, SRTF-P, and RR-P, the threads may be created, and the program must move on to the next available operation command. There is likely to be some synchronization management to keep race conditions from occurring; since it is likely the I/O threads will be updating the same data, which must be released to the display when the thread has completed, this is a pretty clear reader/writer problem, and it must be managed as such.
- if threads are not used, simulated concurrency must still be represented and displayed as if threads were used
- the FCFS-P (i.e., first come, first served, preemptive) strategy must bring in operation commands in order of the process entry. In addition, when a given process is returned from being blocked, it must be placed back into the scheduling queue in its original order. Example: In a program where there are 8 processes, process operations 0, 1, 2, and 3 might all start with I/O, and are sent out as threads. If process 3 returns first, it must be placed back in the scheduling queue in order (e.g., 3, 4, 5, 6, 7) so that the next operation command of process 3 is run next. Later when process 0 is freed, it must be placed in order (e.g., 0, 3, 5, 6, 7) so that the next operation command of process 0 is run next, and so on
- the SRTF-P (i.e., shortest remaining time first, preemptive) strategy must find the process with the shortest total remaining time before each operation command is run, and run the operation command of that process next
- the RR-P (round robin, preemptive) strategy starts the same as FCFS, however when a process is returned either from running or from being blocked, it simply goes back onto the end of the scheduling queue in the order it was returned
- the P/run operation must stop after each complete individual cycle and check for interrupts that have occurred while it was running that cycle. Example: three I/O operation threads are running when a P/run operation requiring 7 cycles is placed in the processing state, where the processing cycle time is 30 mSec. During the first cycle, no interrupts occur, so the system checks for the interrupts, finds none,  and starts the second cycle. At a point 14 mSec into the next run cycle, one I/O thread completes and sends an interrupt signal, and at 22 mSec into the same run cycle, another I/O thread completes and sends an interrupt signal; note that these are concurrent actions. The P/run action must complete its 30 mSec cycle but  when it checks for, and finds the two interrupt requests, the P/run process must  be placed back into the scheduling queue (appropriately, as specified previously in  this document, and with its 7-cycle requirement reduced to 5), and the two I/O  actions must be processed (e.g., each I/O completion transaction must be posted with their correct return times, and the processes having these I/O operations  must be unblocked and appropriately placed back into the scheduling queue, etc.). 
Also, if no I/O operation interrupts occur, the P/run operation must still be stopped at the quantum time (e.g., even though it has a 7-cycle requirement, if the quantum is 3, the P/run operation must be stopped after the third cycle, and it must be placed back in the scheduling queue and its 7-cycle requirement must  now be reduced to 4
- note that it is likely that two or more I/O operations may finish and drive an interrupt while a P/run operation is being conducted; this will require some kind of queueing management for the waiting interrupt requests
- also note that for I/O-bound programs, many, and possibly all, of the processes may be blocked for periods of time; the program must show the processor idling if there are no Ready-state operation commands to be run
- the system must report at least each of the following operation actions: - system start and end
- any state change of any of the processes (e.g., ready, running, etc.) - any selection of a new process as a result of the scheduling requirement - any start or end of any operation command (e.g., hard drive input or output, keyboard input, monitor output, run process actions, etc.); note that the ends of all of the I/O operations are likely to occur at times between  other scheduled operations
- memory management is not required for this assignment; however extra credit will be earned if memory management is correctly implemented. If memory management is implemented, it must meet the requirements provided in the specification for Sim 03
